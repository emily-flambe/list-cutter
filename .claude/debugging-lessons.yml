# Debugging Lessons Learned
# Project-specific debugging knowledge and patterns

WranglerDeploymentIssues: &WranglerDeploymentIssues
  issue_number: "#65"
  problem: "CI deployment failing with 'binding should have a string binding field' error"
  
  root_cause:
    - "Package-lock.json mismatch (v3 lockfile, v4 package.json)"
    - "Complex commented TOML binding configurations causing parsing errors"
  
  key_lessons:
    root_cause_analysis:
      - "Multi-layered Problems: Always check for multiple simultaneous issues"
      - "Environment Parity: CI uses npm ci (strict) vs local npm install (flexible)"
      - "Version Dependencies: Regenerate lockfiles after major version changes"
      - "Configuration Comments: Even commented TOML syntax can break parsers"
    
    technical_debugging:
      - "Test Exact CI Commands: Use npm ci and exact wrangler commands locally"
      - "Transitive Dependencies: Check for conflicting sub-dependencies"
      - "Error Message Validity: binding field error pointed to config, but root cause was version mismatch"
      - "Incremental Changes: Simplify configuration → working deployment → add complexity back"
    
    process_improvements:
      - "Local Testing First: Always reproduce CI environment exactly before pushing"
      - "Systematic Approach: Reproduce → Isolate → Document → Verify → Validate"
      - "Test Scripts: Create validation scripts for consistent testing"
      - "Version Specificity: Use exact versions in package.json for critical dependencies"
    
    wrangler_specific:
      - "Version Compatibility: v3 vs v4 have different binding syntax requirements"
      - "Configuration Validation: Use wrangler deploy --dry-run and wrangler versions upload --dry-run"
      - "Clean Configuration: Remove complex commented binding examples that cause parsing issues"
  
  resolution_commands:
    - "cd cloudflare/workers"
    - "rm -rf node_modules package-lock.json"
    - "npm ci  # This should match CI exactly"
    - "npx wrangler versions upload --dry-run"
    - "npx wrangler deploy --dry-run"
    - "npm run build"
  
  next_time: "Always start by reproducing the exact CI failure locally before making any configuration changes"

TypeScriptBuildFailures: &TypeScriptBuildFailures
  issue_number: "#67"
  problem: "Cloudflare Worker build failing with TypeScript errors, TOML syntax issues, and D1 database type casting problems"
  
  root_cause:
    - "TOML configuration syntax errors (unterminated arrays)"
    - "Binding name mismatches between TypeScript interfaces and Wrangler config"
    - "Unsafe D1 database result type casting without proper validation"
    - "Overly strict TypeScript configuration causing build failures"
  
  key_lessons:
    progressive_problem_solving:
      - "Start with Critical Blockers: Fix syntax errors before type issues"
      - "Layer-by-Layer Resolution: Configuration → Build → Types → Tests"
      - "Permissive-to-Strict Approach: Get builds working first, then tighten constraints"
      - "User Requirements Priority: Focus on essential functionality over perfect types"
    
    typescript_build_config:
      - "Graceful Degradation: Make TypeScript permissive when strict checking blocks progress"
      - "Essential vs Nice-to-Have: Distinguish between critical type safety and perfectionist checking"
      - "Exclude Problematic Areas: Use TypeScript exclude to temporarily bypass complex modules"
      - "Build vs Type-Check: Separate concerns - builds can succeed while types are imperfect"
    
    d1_database_best_practices:
      - "Never use unsafe as Type casting on database results"
      - "Always use Number(), String() conversions instead of direct casting"
      - "Check for null/undefined before type conversion: Number(result?.field) || 0"
      - "Use Record<string, unknown> for database row typing, then convert explicitly"
      - "Validate enum values before casting: ['low','medium','high'].includes(value) ? value : 'default'"
      - "Handle optional chaining for meta properties: result.meta?.changes"
    
    cloudflare_workers_development:
      - "TOML Syntax Validation: Use proper table format instead of inline objects for complex configs"
      - "Binding Name Consistency: Ensure TypeScript env interfaces match wrangler.toml exactly"
      - "Environment Prefixing: Use consistent naming like CUTTY_* for all bindings"
      - "Version Management: Keep Wrangler versions consistent between package.json and CI"
    
    debugging_methodology:
      - "Research Phase: Use Task tool for comprehensive codebase analysis"
      - "Systematic Fixes: One category at a time (config → build → types)"
      - "User Feedback Integration: Adjust strictness based on user priorities"
      - "Verification Loops: Test builds after each major change"
  
  resolution_pattern:
    - "npm run build  # Should pass after TOML fixes"
    - "npx wrangler versions upload  # Should succeed"
    - "npx tsc --noEmit  # Identify remaining issues"
    - "# Use exclude patterns for problematic service directories"
  
  safe_patterns:
    unsafe_examples:
      - "const count = result.count as number;"
      - "severity: event.severity as 'low' | 'medium'"
      - "const row = result as DatabaseRow;"
    
    safe_examples:
      - "const count = Number(result?.count) || 0;"
      - "severity: (['low','medium','high'].includes(event.severity) ? event.severity : 'medium') as 'low' | 'medium' | 'high'"
      - "const row = result as Record<string, unknown>; const safeField = String(row.field_name);"
  
  next_time: "Begin with configuration validation, separate build success from type perfection, and prioritize user requirements over theoretical type safety"

CloudflarePagesVsWorkersDeployment: &CloudflarePagesVsWorkersDeployment
  issue_date: "2025-07-13"
  problem: "Production deployment failing with 'Internal error' after successful PR builds - Cloudflare Pages build command used instead of Workers deployment"
  
  root_cause:
    - "Cloudflare dashboard incorrectly configured for Pages deployment instead of Workers"
    - "Build command in dashboard: 'cd ../../app/frontend && npm ci && npm run build && mkdir -p ../../cloudflare/workers/dist && cp -r dist/* ../../cloudflare/workers/dist/ && cd ../../cloudflare/workers && npm ci && npm run build'"
    - "wrangler.toml assets directory pointing to wrong path (local 'dist' instead of '../../app/frontend/dist')"
    - "Confusion between Pages (static sites) vs Workers (serverless functions) deployment methods"

  key_lessons:
    deployment_architecture_clarity:
      - "Workers vs Pages Distinction: Workers = serverless functions with assets, Pages = static sites with functions"
      - "Build Strategy: Workers should use 'wrangler deploy' with assets binding, not complex multi-step builds"
      - "Dashboard Configuration: Always verify deployment type matches architecture (Workers project = Workers deployment)"
      - "Asset Path Consistency: wrangler.toml assets directory must match actual build output location"
    
    debugging_methodology:
      - "Success vs Failure Context: PR builds succeeded because they used GitHub Actions (Workers CI), production used Pages build"
      - "Error Message Analysis: 'Internal error' in Cloudflare often indicates configuration mismatch, not code issues"
      - "Configuration Audit: When builds work in CI but fail in production, check deployment configuration differences"
      - "Platform-Specific Debugging: Different Cloudflare services have different error patterns and solutions"
    
    cloudflare_deployment_best_practices:
      - "Workers Deployment: Use 'wrangler deploy' with proper wrangler.toml configuration"
      - "Assets Binding: Configure [assets] directory to point to frontend build output location"
      - "Build Command Simplicity: 'cd ../../app/frontend && npm ci && npm run build && cd ../../cloudflare/workers && npm ci && npm run build && wrangler deploy'"
      - "Dashboard Verification: Always verify deployment type and build commands match intended architecture"
    
    prevention_strategies:
      - "Documentation: Clearly document whether project uses Workers or Pages deployment"
      - "Configuration Management: Keep wrangler.toml and dashboard settings in sync"
      - "Testing Parity: Ensure local development, CI, and production use same deployment method"
      - "Deployment Validation: Test exact production build command locally before configuring in dashboard"

  resolution_steps:
    - "Identified build command was Pages-style instead of Workers deployment"
    - "Updated wrangler.toml: directory = '../../app/frontend/dist' (not 'dist')"
    - "Set correct Workers build command: 'cd ../../app/frontend && npm ci && npm run build && cd ../../cloudflare/workers && npm ci && npm run build && wrangler deploy'"
    - "Verified GitHub Actions CI continues to work with Workers-only builds"

  warning_signs:
    - "Build commands copying files between directories unnecessarily"
    - "Complex multi-step builds when simple 'wrangler deploy' should suffice" 
    - "Success in CI but failure in production with 'Internal error'"
    - "Deployment type mismatch between dashboard configuration and actual architecture"

  next_time: "Always verify Cloudflare deployment type matches architecture (Workers vs Pages) and ensure build commands are appropriate for the chosen platform. Document deployment strategy clearly to avoid confusion."

GoogleOAuthImplementation: &GoogleOAuthImplementation
  issue_date: "2025-07-14"
  implementation: "Complete Google OAuth 2.0 authentication system"
  github_pr: "https://github.com/emily-flambe/list-cutter/pull/105"
  
  key_decisions:
    architecture_approach:
      - "Security-First Design: Multi-layered rate limiting and comprehensive security event logging"
      - "Backward Compatibility: Maintains existing email/password authentication alongside OAuth"
      - "Account Linking: Allows users to link Google accounts to existing profiles"
      - "Production-Ready: Full error handling, monitoring, and extensive testing coverage"
    
    implementation_patterns:
      - "JWT-Signed State Tokens: Use existing JWT infrastructure for OAuth state management"
      - "Service Layer Architecture: Separate OAuth service, rate limiter, and security middleware"
      - "Database Extension: Extend existing users table rather than creating separate OAuth tables"
      - "Frontend Component Strategy: Reusable GoogleSignInButton with multiple modes"
    
    security_measures:
      - "State Token Validation: JWT-signed tokens with 10-minute expiration and nonce verification"
      - "Rate Limiting: Multi-layered protection (general, failure, burst, suspicious activity)"
      - "Input Validation: Comprehensive validation of all OAuth parameters and return URLs"
      - "Security Logging: All OAuth events logged to database for monitoring and analysis"
  
  technical_solutions:
    state_management:
      - "Use existing JWT infrastructure for signing OAuth state tokens"
      - "Include nonce, timestamp, and return URL in state payload"
      - "Validate state tokens on callback with comprehensive security checks"
      - "Store state tokens in database for additional validation layer"
    
    rate_limiting_strategy:
      - "General limit: 30 OAuth attempts per 15 minutes per IP"
      - "Failure limit: 15 failed attempts per 15 minutes per IP"
      - "Burst protection: 15 attempts per minute per IP"
      - "Suspicious activity: 10 failures in 5 minutes triggers critical alert"
    
    database_design:
      - "Extend users table with OAuth fields (google_id, provider, profile info)"
      - "Create oauth_states table for CSRF protection and state management"
      - "Create oauth_security_events table for comprehensive security logging"
      - "Create oauth_rate_limits table for multi-layered rate limiting"
      - "Use database indexes for optimal OAuth lookup performance"
    
    frontend_integration:
      - "GoogleSignInButton component with modes: login, signup, link"
      - "GoogleOAuthCallback component for handling OAuth redirect processing"
      - "GoogleAccountStatus component for account management"
      - "Integration with existing AuthContext for seamless authentication flow"
  
  security_best_practices:
    oauth_flow_security:
      - "Always validate OAuth state parameter to prevent CSRF attacks"
      - "Use short-lived state tokens (10 minutes) to minimize attack window"
      - "Validate authorization code format and length before processing"
      - "Verify Google ID token signature and claims (audience, issuer, expiration)"
      - "Log all OAuth events for security monitoring and incident response"
    
    input_validation:
      - "Validate return URLs to prevent open redirect attacks"
      - "Sanitize all OAuth parameters to prevent injection attacks"
      - "Check authorization code format using regex patterns"
      - "Limit parameter lengths to prevent buffer overflow attempts"
      - "Block suspicious user agents and IP patterns"
    
    production_considerations:
      - "Configure proper CORS headers for OAuth redirect domains"
      - "Set up monitoring alerts for high OAuth failure rates"
      - "Use environment-specific redirect URIs in Google Cloud Console"
      - "Monitor rate limiting analytics for attack pattern detection"
      - "Implement proper error handling without exposing sensitive information"
  
  testing_strategy:
    test_coverage_areas:
      - "OAuth service integration tests with mock Google responses"
      - "Rate limiting validation with various attack scenarios"
      - "Security middleware tests for input validation and protection"
      - "API route tests for all OAuth endpoints and error conditions"
      - "Frontend component tests for OAuth button interactions"
    
    security_test_patterns:
      - "Test rate limiting enforcement with automated request sequences"
      - "Validate input sanitization with malicious payload injection"
      - "Test state token validation with expired and invalid tokens"
      - "Verify authorization code validation with various attack vectors"
      - "Test suspicious activity detection with automated bot patterns"
  
  deployment_workflow:
    development_setup:
      - "Configure Google Cloud Console OAuth application with dev redirect URIs"
      - "Set up .dev.vars file with development OAuth credentials"
      - "Run OAuth database migration: migrations/0009_google_oauth_support.sql"
      - "Test OAuth flow locally with proper secret configuration"
    
    production_deployment:
      - "Configure production OAuth secrets via wrangler secret commands"
      - "Update Google Cloud Console with production redirect URIs"
      - "Apply OAuth database migration to production database"
      - "Verify OAuth endpoints work end-to-end in staging environment"
      - "Monitor OAuth security events and rate limiting analytics"
  
  lessons_learned:
    development_efficiency:
      - "Team Approach: Using subagent archetypes improved code organization and specialization"
      - "Security-First: Implementing security measures from the start prevents vulnerabilities"
      - "Testing Coverage: Comprehensive tests caught integration issues early"
      - "Documentation: Detailed setup guides prevent configuration errors"
    
    security_insights:
      - "Multi-Layered Protection: Multiple rate limiting strategies provide robust defense"
      - "State Management: JWT-signed state tokens provide strong CSRF protection"
      - "Input Validation: Comprehensive validation prevents various attack vectors"
      - "Monitoring: Security event logging enables proactive threat detection"
    
    integration_patterns:
      - "Backward Compatibility: OAuth integration doesn't disrupt existing authentication"
      - "Account Linking: Users can seamlessly connect OAuth to existing accounts"
      - "Error Handling: Graceful error handling maintains user experience"
      - "Frontend Integration: React components integrate cleanly with existing UI"
  
  performance_optimizations:
    database_efficiency:
      - "OAuth table indexes improve lookup performance for rate limiting"
      - "State token cleanup prevents database bloat from expired tokens"
      - "Security event batching reduces database write overhead"
      - "User lookup optimization with proper Google ID indexing"
    
    api_performance:
      - "Rate limiting checks are fast with indexed database queries"
      - "OAuth state validation uses efficient JWT verification"
      - "Security middleware adds minimal overhead to request processing"
      - "Frontend components lazy-load OAuth functionality when needed"
  
  next_implementations:
    potential_enhancements:
      - "Additional OAuth Providers: Framework supports extending to other providers"
      - "Advanced Security: Machine learning for anomaly detection in OAuth patterns"
      - "User Experience: Remember device functionality for trusted OAuth sessions"
      - "Analytics Dashboard: Real-time OAuth usage and security metrics visualization"
    
    scaling_considerations:
      - "Rate Limiting: Consider Redis for distributed rate limiting across multiple workers"
      - "Security Events: Consider streaming security events to external monitoring systems"
      - "Database Scaling: Plan for OAuth table growth with user base expansion"
      - "Monitoring: Implement alerting for OAuth security thresholds"
  
  next_time: "This OAuth implementation provides a solid foundation for secure, scalable authentication. The multi-layered security approach, comprehensive testing, and detailed documentation ensure maintainable and secure OAuth integration. Future implementations should follow this security-first pattern with extensive testing and monitoring."

ProjectNamingConsistency: &ProjectNamingConsistency
  issue_date: "2025-07-13" 
  problem: "Package name inconsistency between 'cutty-workers' and unified 'cutty' architecture"
  
  root_cause:
    - "Package.json still had old name 'cutty-workers' from previous multi-worker architecture"
    - "Recent commit 317c8c7 renamed worker to 'cutty' for unified architecture but package.json wasn't updated"
    - "Inconsistency between documented naming conventions and actual package configuration"
  
  key_lessons:
    naming_consistency:
      - "Package names must match worker names and unified architecture decisions"
      - "When renaming projects for architectural changes, update all configuration files"
      - "Document naming conventions clearly and enforce across all config files"
      - "Use consistent naming between package.json, wrangler.toml, and documentation"
    
    configuration_audit:
      - "Regular audits prevent configuration drift between actual and documented state"
      - "Version updates should be synchronized across documentation and package files"
      - "Test configuration exclusions should match documented testing philosophy"
      - "Claude configuration should reflect current project state, not planned state"
  
  resolution_steps:
    - "Updated package.json name from 'cutty-workers' to 'cutty'"
    - "Added analytics-engine exclusion to vitest.config.ts per testing philosophy"
    - "Synchronized documented versions with actual package.json versions"
    - "Verified wrangler.toml naming matches unified architecture"
  
  prevention_strategies:
    - "Include configuration files in architectural change checklists"
    - "Regular .claude configuration audits as part of development workflow"
    - "Version synchronization between documentation and actual dependencies"
    - "Clear documentation of testing exclusions and rationale"
  
  next_time: "When making architectural naming changes, systematically update all configuration files including package.json, documentation, and Claude configs to maintain consistency."

JWTTestTypeConsistency: &JWTTestTypeConsistency
  issue_date: "2025-07-13"
  problem: "JWT authentication tests failing with type mismatches - User.id number vs string, payload verification errors, and duplicate JWT claims"
  github_action_run: "https://github.com/emily-flambe/list-cutter/actions/runs/16251406149/job/45881577112?pr=96"
  
  root_cause:
    - "Test mock used User.id = 1 (number) but UserJWTPayload.user_id expects string type"
    - "verifyJWT function assumed jose library returns typed payloads but it returns mixed types requiring conversion"
    - "generateJWT function was setting JWT claims twice (in payload object and via method calls)"
    - "No proper type conversion between jose library JWTPayload and application UserJWTPayload interface"
  
  key_lessons:
    jwt_testing_best_practices:
      - "Mock Data Type Consistency: Always ensure test mocks match actual TypeScript interfaces exactly"
      - "Library Payload Handling: External JWT libraries often return generic types requiring explicit conversion"
      - "Type Guards vs Casting: Use explicit type conversion (String(), Number()) instead of type assertions"
      - "Test-First Interface Design: Write tests that match your interface contracts, not library implementations"
    
    jose_library_specific:
      - "JWTPayload Type Reality: jose.jwtVerify() returns JWTPayload with mixed/unknown field types"
      - "Required Field Validation: Always check payload field existence before type conversion"
      - "Claim Setting Duplicates: Don't set claims both in payload object AND via SignJWT methods"
      - "Type Conversion Pattern: Convert all payload fields to expected types explicitly"
    
    typescript_jwt_patterns:
      - "Safe Payload Conversion: Create typed payload objects rather than casting unknown types"
      - "Null Safety: Use optional chaining and nullish coalescing for payload fields"
      - "Type Interface Alignment: Ensure mock data types match production interface types exactly"
      - "Library Bridge Pattern: Create conversion functions between library types and application types"
    
    test_failure_debugging:
      - "GitHub Actions Analysis: Review exact error messages and line numbers from CI logs"
      - "Type Mismatch Patterns: number vs string, undefined vs expected values are common JWT issues"
      - "Sequential Fixing: Fix type consistency in tests first, then payload verification logic"
      - "End-to-End Verification: Test entire JWT generation → verification → extraction flow"
  
  resolution_pattern:
    test_fixes:
      - "Update test mocks to use correct types: id: '1' not id: 1"
      - "Add explicit type conversion in verification functions"
      - "Remove duplicate JWT claim setting in generation"
      - "Create typed payload conversion utilities"
    
    safe_jwt_verification:
      - "const typedPayload: UserJWTPayload = { user_id: String(payload.user_id), username: String(payload.username), ... }"
      - "Validate existence before conversion: if (!payload.user_id || !payload.username) throw error"
      - "Handle optional fields: email: payload.email ? String(payload.email) : undefined"
      - "Convert numbers safely: exp: Number(payload.exp), iat: Number(payload.iat)"
  
  prevention_checklist:
    before_jwt_implementation:
      - "[ ] Define TypeScript interfaces for all JWT payload types"
      - "[ ] Create type conversion utilities between library and application types"
      - "[ ] Write tests with correctly typed mock data"
      - "[ ] Validate payload fields exist before type conversion"
    
    during_testing:
      - "[ ] Ensure all mock User objects use string IDs to match database schema"
      - "[ ] Test JWT generation and verification as integrated flow"
      - "[ ] Verify error handling for malformed payloads"
      - "[ ] Check type conversion handles undefined/null gracefully"
    
    deployment_verification:
      - "[ ] Run npm test to verify all JWT tests pass"
      - "[ ] Test actual token generation/verification in development environment"
      - "[ ] Verify frontend can consume JWT payloads correctly"
      - "[ ] Check production token compatibility after changes"
  
  error_patterns_to_watch:
    - "TypeError: actual value must be number or bigint, received 'undefined'"
    - "AssertionError: expected undefined not to be undefined"
    - "AssertionError: expected true to be false (token verification failures)"
    - "Type mismatch errors in test expectations vs actual payload values"
  
  next_time: "Always ensure JWT test mocks use correct TypeScript interface types, implement proper type conversion between library payloads and application interfaces, and avoid duplicate claim setting in JWT generation."